#!/bin/bash

# THIS VERSION IS A COPY OF THE LATEST VERSION AT 3 June 2017, AND MADE FOR RAIJIN

set -x # echo on, command fails causes script to exit, pipes fail

# get the directory of the current script
# from https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done

# set relative directory variables
BIN_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
SCRIPTS_DIR=$BIN_DIR/../scripts
SHARE_DIR=$BIN_DIR/../share

>&2 echo "Running VDJPuzzle executable from directory: $BIN_DIR"
>&2 echo "Running on date: " `date`

function printHelp {
	>&2 echo "VDJPuzzle v2.0"
	>&2 echo "Usage: ./vdjpuzzle directory_name [option]"
	>&2 echo -e "--qsub\texecutes on the cluster (overrides --CPU flag)"
	>&2 echo -e "--type=(t|b)\tspecifies tcell (default) or bcell analysis"
	>&2 echo -e "--CPU=n\truns with n processes"
	>&2 echo -e "--THR=n\truns bowtie and tophat with n threads (default 8)"
	>&2 echo -e "--species=(human|mouse)\tspecified human (default) or mouse organism"
	>&2 echo -e "--err-corr\tPerform final error correction on consensus sequence"
	>&2 echo -e "--only-statistics\tExecutes only summary statistics script"
	>&2 echo -e "--no-statistics\tDo not execute summary statistics script"
	>&2 echo -e "--transcriptomic\tEnable cuffquant/cuffnorm gene quantification measurements"
	>&2 echo -e "--trim\tTrim reads using Trimmomatic"
	>&2 echo -e "--counts\tEnable featureCounts gene quantification measurements"
}

function testArg {
	if [[ "$1" =~ $2 ]]; then
		local result='true'
	else
		local result='false'
	fi
	echo "$result"
}

function waitForProcess {
	sleep_time=120
	status=`qstat -u $USER | grep "p${1}_${2}"`
	while [ -n "${status}" ] # while $status is not empty
	do
		sleep $sleep_time
		status=`qstat -u $USER | grep "p${1}_${2}"`
	done
}

# module unload samtools/0.1.18
# module load tophat/2.0.7
# module unload samtools/1.3.1
# module load samtools/0.1.18
# module load bowtie2/2.1.0
#
# module load cufflinks/2.2.1
# module load bedtools/2.26.0
# module load blast/2.2.28+

#CONFIGURE SCRIPT PATHS
# export PATH=/apps/bowtie2/2.1.0/:$PATH
# export PATH=/short/va1/fzl561/scRNAseq/Tools/bowtie/bowtie-1.1.2/:$PATH
# export PATH=/apps/samtools/0.1.18/bin/:$PATH
# export PATH=/apps/java/jdk1.7.0_25/bin/:$PATH
# export PATH=/short/va1/fzl561/scRNAseq/Tools/Blast/usr/bin/:$PATH
# export PATH=/short/va1/fzl561/scRNAseq/Tools/igblastwrapper_linux64/bin/:$PATH
# export PATH=/apps/cufflinks/2.2.1/bin/:$PATH
# export PATH=/short/va1/fzl561/scRNAseq/Tools/cufflinks-2.2.1.Linux_x86_64/:$PATH
export MIGMAP=`which migmap` #/short/va1/fzl561/scRNAseq/Tools/migmap-0.9.7/migmap-0.9.7.jar
export trinitypath=`which Trinity` #/short/va1/fzl561/scRNAseq/Tools/trinityrnaseq-2.0.6/Trinity
export TOPHAT=`which tophat2` # /apps/tophat/2.0.7/tophat2
export BOWTIE=`which bowtie2` # /apps/bowtie2/2.1.0/bowtie2
export BOWTIEBUILD=`which bowtie2-build` # /apps/bowtie2/2.1.0/bowtie2-build
export SAMTOOLS=`which samtools` # /apps/samtools/0.1.18/bin/samtools
export BEDTOOLS=`which intersectBed` # /apps/bedtools/2.26.0/bin/intersectBed
#export JAVA18=/apps/java/jdk1.8.0_60/bin/java #Java18 is included in the package so don't edit this path
if [[ ! -z ${CONDA_PREFIX+x} ]]; then
	export TRIMMOMATIC=`which trimmomatic` # /short/va1/fzl561/scRNAseq/Tools/Trimmomatic-0.36/trimmomatic-0.36.jar
else
	export TRIMMOMATIC=/short/va1/fzl561/scRNAseq/Tools/Trimmomatic-0.36/trimmomatic-0.36.jar
fi
export featureCounts=`which featureCounts` # /short/va1/fzl561/scRNAseq/Tools/subread/subread-1.5.1-Linux-x86_64/bin/featureCounts

### TRIMMING PARAMETERS ###


if [[ ! -z ${CONDA_PREFIX+x} ]]; then
	export ADAPTERS=${CONDA_PREFIX}/share/trimmomatic/adapters/NexteraPE-PE.fa
else
	export ADAPTERS=$(echo $TRIMMOMATIC | egrep -o ".*\/")adapters/NexteraPE-PE.fa
fi
export LEADING=3
export TRAILING=3
export WINDOW_LEN=4
export WINDOW_QUAL=15
export MINLEN=50
export AVGQUAL=20

#SET DEFAULT PARAMETERS
PARALLEL=1
ERRCORR=0
NTHREADS=1
COUNTS=0
RUNTCR=1
RUNR=1
ORGANISM=human
TRIM=0
QSUB=0
TRANSCRIPTOMIC=0
TYPE='t'


# make log directory
mkdir -p log

#PARSING PARAMETERS
for i in "$@"
do
	case $i in
		-h|--help)
		printHelp
		exit 0
		shift
		;;

		--qsub)
		QSUB=1
		shift
		;;

		--type=*)
		TYPE="${i#*=}"
		if [[ "$(testArg $TYPE '^[tb]$')" != "true" ]]; then
			printHelp
			exit
		fi
		shift
		;;

		--CPU=*)
		PARALLEL="${i#*=}"
		if [[ "$(testArg $PARALLEL '^[0-9]+$')" != "true" ]]; then
			printHelp
			exit
		fi
		shift
		;;

		--THR=*)
		NTHREADS="${i#*=}"
		if [[ "$(testArg $NTHREADS '^[0-9]+$')" != "true" ]]; then
			printHelp
			exit
		fi
		shift
		;;

		--only-statistics)
		RUNTCR=0
		shift
		;;

		--species=*)
		ORGANISM="${i#*=}"
		if [[ "$(testArg $ORGANISM '(mouse|human)')" != "true" ]]; then
			printHelp
			exit
		fi
		shift
		;;

		--err-corr)
		ERRCORR=1
		shift
		;;

		--transcriptomic)
		TRANSCRIPTOMIC=1
		shift
		;;

		--trim)
		TRIM=1
		shift
		;;

		--counts)
		COUNTS=1
		shift
		;;

		--no-statistics)
		RUNR=0
		shift
		;;

		--bowtie-index=*)
		BOWTIE_INDEX="${i#*=}"
		if [[ ! -f "${BOWTIE_INDEX}.1.bt2" || -z ${BOWTIE_INDEX+x} ]]; then
			>&2 echo "Error: could not find index at ${BOWTIE_INDEX}.1.bt2"
			printHelp
			exit 1
		fi
		export BOWTIE_INDEX
		# default /short/va1/fzl561/scRNAseq/refGenome/$ORGANISM/Bowtie2Index/${cell_type}genome
		shift
		;;

    --gtf=*)
		ANNOTATION="${i#*=}"
		if [[ ! -f "${ANNOTATION}" || -z ${ANNOTATION+x} ]]; then
			>&2 echo "Error: could not find GTF annotation at ${ANNOTATION}."
			printHelp
			exit 1
		fi
		export ANNOTATION
		# default /short/va1/fzl561/scRNAseq/refGenome/$ORGANISM/Genes/genes.gtf
		shift
		;;

		*)

		if [[ ! -d "$i" ]]; then
			echo "Invalid SC_RNA_SEQ directory: $i"
			printHelp
			exit
		fi
		echo "SC_RNA_SEQ Directory $i"
		RNADIR=$i
		shift
		;;
	esac
done

if [[ -z "$RNADIR" ]]; then
	echo "VDJPuzzle requires a positional argument, directory_name."
	printHelp
	exit 1
fi

if [[ -z "$BOWTIE_INDEX" ]]; then
	echo "No bowtie index path provided, using default path"
        BOWTIE_INDEX=/short/va1/fzl561/scRNAseq/refGenome/$ORGANISM/Bowtie2Index/genome
        export BOWTIE_INDEX
fi

if [[ -z "$ANNOTATION" ]]; then
	echo "No gene annotation file provided, using default path"
        ANNOTATION=/short/va1/fzl561/scRNAseq/refGenome/$ORGANISM/Genes/genes.gtf
        export ANNOTATION
fi

#CONFIGURE REFERENCE PATHS

if [ "$TYPE" == "t" ]; then
	CHAIN_ARRAY=('TCRA' 'TCRB')
	CHAIN_PREFIX_ARRAY=('a' 'b')
	cell_type='tcell_'
else
	CHAIN_ARRAY=('IGH' 'IGK' 'IGL')
	CHAIN_PREFIX_ARRAY=('h' 'k' 'l')
	cell_type='bcell_'
fi

if [[ $TRANSCRIPTOMIC -ge 1 ]]; then
	cell_type=''
fi

#export ENSEMBL=/short/va1/fzl561/scRNAseq/refGenome/$ORGANISM/Bowtie2Index/${cell_type}genome # now BOWTIE_INDEX
#export ANNOTATION=/short/va1/fzl561/scRNAseq/refGenome/$ORGANISM/Genes/genes.gtf

for chain in "${CHAIN_ARRAY[@]}"
do
	export $chain=$SHARE_DIR/bed_files/${chain//C}_${ORGANISM}.bed
	#export $chain=/short/va1/fzl561/scRNAseq/refGenome/BED_files/${chain//C}_$ORGANISM.bed
done

export CUFFOUTPUT=$PWD/CuffQuant
export COUNTOUTPUT=$PWD/ReadCounts

echo "parallel = $PARALLEL
qsub = $QSUB
threads = $NTHREADS
counts = $COUNTS
organism = $ORGANISM
runtcr = $RUNTCR
runr = $RUNR
trim = $TRIM
type = $TYPE
transcriptomic = $TRANSCRIPTOMIC
chain_array = ${CHAIN_ARRAY[*]}
chain_prefix_array = ${CHAIN_PREFIX_ARRAY[*]}"

RECEPTOR_ABBREV="$(echo $TYPE | tr '[:lower:]' '[:upper:]')CR"

#MAKE SURE TO HAVE THE ABSOLUTE PATH WITHOUT / AT THE END
CURDIR="$PWD"
cd $RNADIR
RNADIR="$PWD"
cd $CURDIR

if [ "$TRANSCRIPTOMIC" -ge 1 ]; then
	mkdir -p $CUFFOUTPUT
	echo "Transcriptomic quantification"
	echo -e "sample_name\tgroup" > $CUFFOUTPUT/sample_sheet.txt
fi


echo "STARTING PART 1 : Geneating preliminary VDJ repertoire"
#PART1 - GENERATE PRELIMINARY VDJ REPERTOIRE
if [[ $QSUB -ge 1 ]] ; then
	N=1
	for d in $RNADIR/*
	do
		echo $d
		di=${d%%/};
		echo $di
		nfiles=$(find -L $di/*fastq* -type f | wc -l)
		if [ "$nfiles" -ge 2 ]; then
			filename=$(basename $di)
			qsub -N "p1_${TYPE}_$N" -e "log/p1_${TYPE}_$N.err" -o "log/p1_${TYPE}_$N.out" -V -v P1=$di,P2=$filename,P3=$ORGANISM,P4=$PWD,P5=$TRANSCRIPTOMIC,P6=$TRIM,P7="${CHAIN_ARRAY[*]}",P8="${CHAIN_PREFIX_ARRAY[*]}",P9=$NTHREADS,PATH_PARAM=$PATH $SCRIPTS_DIR/run_tcr_method2_sc_part1.sh
		fi
		N=$((N+1))
	done
	waitForProcess 1 $TYPE

else
	N=0
	for d in $RNADIR/*
	do
		echo $d
		di=${d%%/};
		echo $di
		nfiles=$(find -L $di/*fastq* -type f | wc -l)
		if [ "$nfiles" -ge 2 ]; then
			filename=$(basename $di)
			if (( $N % $PARALLEL == 0 )) ; then
				wait
			fi
			$SCRIPTS_DIR/run_tcr_method2_sc_part1.sh $di $filename $ORGANISM $PWD $TRANSCRIPTOMIC $TRIM "${CHAIN_ARRAY[*]}" "${CHAIN_PREFIX_ARRAY[*]}" $NTHREADS &
		fi
		N=$((N+1))
	done
	wait
fi

if [ "$TRANSCRIPTOMIC" -ge 1 ]; then
	find "$CUFFOUTPUT"/* -type d -exec echo -ne "{}/abundances.cxb\t" \; -exec sh -c "echo {} | sed 's/.*\///'" \; >> $CUFFOUTPUT/sample_sheet.txt
	if [[ $QSUB -ge 1 ]] ; then
		qsub -N "pcuff_${TYPE}_cuffnorm" -e "log/pcuff_${TYPE}_cuffnorm.err" -o "log/pcuff_${TYPE}_cuffnorm.out" -V -v ANNOTATION=$ANNOTATION,CUFFOUTPUT=$CUFFOUTPUT,PATH_PARAM=$PATH $SCRIPTS_DIR/run_cuffnorm.sh
	else
		cuffnorm --use-sample-sheet -o CuffNorm $ANNOTATION $CUFFOUTPUT/sample_sheet.txt
	fi
fi

if [ -d preliminary ]; then
	rm -rf preliminary
fi

mkdir -p preliminary
mv VDJ_p1* preliminary/

if [ "$COUNTS" -ge 1 ]; then
	mkdir -p $COUNTOUTPUT
	find preliminary -name 'accepted_hits.bam' -type f > $COUNTOUTPUT/bam_files.txt
	mapfile -t <$COUNTOUTPUT/bam_files.txt
	featureCounts --primary -a $ANNOTATION -o "$COUNTOUTPUT/featureCounts.csv" "${MAPFILE[@]}"
	sed 1d "$COUNTOUTPUT/featureCounts.csv" | cut -f1,7- | sed s/Geneid/id/ > "$COUNTOUTPUT/featureCounts_formatted.csv"
fi

echo "PART 1 COMPLETE: Preliminary $RECEPTOR_ABBREV repertoire reconstructed."

echo "STARTING PART 2: Building a new reference geonme based on the preliminary repertoire"
#PART2 - BUILD A NEW REFERENCE GENOME BASED ON THE PRELIMINARY REPERTOIRE
for chain_prefix in "${CHAIN_PREFIX_ARRAY[@]}"
do
	if [[ -f all_sequences_${chain_prefix}.fa ]]; then
		rm -f all_sequences_${chain_prefix}.fa
	fi;
done

if [[ $QSUB -ge 1 ]] ; then
	N=1
	for d in $PWD/preliminary/*
	do
		echo $d
		di=${d%%/};
		echo $di
		nfiles=$(find -L $di/*fastq* -type f | wc -l)
		if [ "$nfiles" -ge 2 ]; then
			filename=$(basename $di)
			qsub -N "p2_${TYPE}_$N" -e "log/p2_${TYPE}_$N.err" -o "log/p2_${TYPE}_$N.out" -V -v P1=$di,P2=$ORGANISM,P3=$PWD,P4=$N,P5="${CHAIN_ARRAY[*]}",P6="${CHAIN_PREFIX_ARRAY[*]}",PATH_PARAM=$PATH $SCRIPTS_DIR/run_tcr_method2_sc_part2.sh
		fi
		N=$((N+1))
	done
	waitForProcess 2 $TYPE

else
	N=0
	for d in $PWD/preliminary/*
	do
		echo $d
		di=${d%%/};
		echo $di
		nfiles=$(find -L $di/*fastq* -type f | wc -l)
		if [ "$nfiles" -ge 2 ]; then
			filename=$(basename $di)
			if (( $N % $PARALLEL == 0 )) ; then
				wait
			fi
			$SCRIPTS_DIR/run_tcr_method2_sc_part2.sh $di $ORGANISM $PWD $N "${CHAIN_ARRAY[*]}" "${CHAIN_PREFIX_ARRAY[*]}" &
			N=$((N+1))
		fi
	done
	wait
fi


for chain_prefix in "${CHAIN_PREFIX_ARRAY[@]}"
do
	cat matching_reads_${chain_prefix}_* > all_sequences_${chain_prefix}.fa
done

index=0
for chain in "${CHAIN_ARRAY[@]}"
do
	bowtie2-build -f all_sequences_${CHAIN_PREFIX_ARRAY[$index]}.fa $chain
	index=$((index+1))
done

mkdir -p assembled${RECEPTOR_ABBREV}_genome
mv *.bt2 assembled${RECEPTOR_ABBREV}_genome/

mkdir -p summary2
mv summary/* summary2/

echo "PART 2 COMPLETE: Finished building reference genome"


echo "STARTING PART 3: Realigning reads to newly constructed genome"
#PART3 -
if [[ $QSUB -ge 1 ]] ; then
	N=1
	for d in $RNADIR/*
	do
		echo $d
		di=${d%%/};
		echo $di
		nfiles=$(find -L $di/*fastq* -type f | wc -l)
		if [ "$nfiles" -ge 2 ]; then
			filename=$(basename $di)
			qsub -N "p3_${TYPE}_$N" -e "log/p3_${TYPE}_$N.err" -o "log/p3_${TYPE}_$N.out" -V -v P1=$di,P2=$filename,P3=$ORGANISM,P4=$PWD,P5=$TRIM,P6="${CHAIN_ARRAY[*]}",P7="${CHAIN_PREFIX_ARRAY[*]}",P8=$NTHREADS,P9="$RECEPTOR_ABBREV",PATH_PARAM=$PATH $SCRIPTS_DIR/run_tcr_method2_sc_part3.sh
			N=$((N+1))
		fi
	done
	waitForProcess 3 $TYPE

else
	N=0
	for d in $RNADIR/*
	do
		echo $d
		di=${d%%/};
		echo $di
		nfiles=$(find -L $di/*fastq* -type f | wc -l)
		if [ "$nfiles" -ge 2 ]; then
			filename=$(basename $di)
			if (( $N % $PARALLEL == 0 )) ; then
				wait
			fi
			$SCRIPTS_DIR/run_tcr_method2_sc_part3.sh $di $filename $ORGANISM $PWD $TRIM "${CHAIN_ARRAY[*]}" "${CHAIN_PREFIX_ARRAY[*]}" $NTHREADS $RECEPTOR_ABBREV &
			N=$((N+1))
		fi
	done
	wait
fi

rm -r ${RECEPTOR_ABBREV}sequences
mkdir -p ${RECEPTOR_ABBREV}sequences
mv VDJ_p3* ${RECEPTOR_ABBREV}sequences/

echo "PART 3 COMPLETE: Reads aligned and receptor repertoires assembled"

echo "Compiling results"

# UPDATE SUMMARY FOLDER WITH LATEST
echo '#!/bin/bash' > mv${RECEPTOR_ABBREV}.sh
for chain in "${CHAIN_ARRAY[@]}"
do
	find summary2 -name "${chain//C}_*" -exec awk 'END { if (NR > 1) print "mv " FILENAME " summary/" }' {} \; >> mv${RECEPTOR_ABBREV}.sh
done
chmod a+x mv${RECEPTOR_ABBREV}.sh
./mv${RECEPTOR_ABBREV}.sh

if [ "$RUNR" -ge 1 ]; then

	index=0
	for chain in "${CHAIN_ARRAY[@]}"
	do
		cat summary/${chain//C}* > summary/h${index}.txt
		head -1 summary/h${index}.txt > summary/header${index}.txt
		rm summary/${chain//C}tmp.txt
		rm summary/${chain//C}_cells.txt
		rm summary/${chain//C}.csv

		for tcr in summary/${chain//C}*;
		do
			if [ "$(cat $tcr | wc -l)" -ge 2 ]; then
				number="$(cat $tcr | wc -l)"
				number="$(expr $number - 1)"
				for i in `seq $number`; do
					echo ${tcr##*/} >> summary/${chain//C}_cells.txt
				done
				tail -n +2 $tcr >> summary/${chain//C}tmp.txt
			fi
		done

		cat summary/header${index}.txt summary/${chain//C}tmp.txt > summary/single_cells_${chain//C}.txt
		echo "CellID" > summary/single_cells_ID_${chain//C}.txt
		cat summary/${chain//C}_cells.txt >> summary/single_cells_ID_${chain//C}.txt
		paste -d"\t" summary/single_cells_ID_${chain//C}.txt summary/single_cells_${chain//C}.txt > summary/${chain//C}.csv
		rm summary/h${index}.txt
		rm summary/header${index}.txt
		rm summary/${chain//C}tmp.txt
		rm summary/${chain//C}_cells.txt
		rm summary/single_cells_${chain//C}.txt
		rm summary/single_cells_ID_${chain//C}.txt
		index=$((index+1))
	done
fi

# wait for cuffnorm to finish
waitForProcess cuff $TYPE

if [[ $ERRCORR -ge 1 ]] ; then
	# ERROR CORRECTION
	# Requires fasta file of reference (reconstructed) sequences and paired end reads
	# Will run migmap, take identified sequences, align reads and produce the corrected consensus sequence

	for chain in "${CHAIN_ARRAY[@]}"
	do
		R1="reads_${chain}_1.fastq"
		R2="reads_${chain}_2.fastq"

		# # Set up fasta filename containing all reconstructed sequences
		# if [[ $TYPE == 't' ]] ; then
		# 	# tcr_[ab].fa
		# 	ORIG_REF="$(echo $chain | tr '[:upper:]' '[:lower:]' | sed -e 's/^.\{3\}/&_/').fa"
		# else
		# 	# ig_[hkl].fa
		# 	ORIG_REF="$(echo $chain | tr '[:upper:]' '[:lower:]' | sed -e 's/^.\{2\}/&_/').fa"
		# fi

		# create directory for storing results
		OUTPUT=$CURDIR/"$(echo ${chain//c} | tr '[:upper:]' '[:lower:]')"_err_corr

		# echo "CURDIR:\t$CURDIR\nR1:\t$R1\nR2:\t$R2\nORIG_REF:\t$ORIG_REF\nOUTPUT:\t$OUTPUT\n"

		if [[ -e $OUTPUT ]]
		then
			echo "Output directory already exits, removing it"
			rm -vr $OUTPUT
		fi
		mkdir $OUTPUT

		for cell in $CURDIR/${RECEPTOR_ABBREV}sequences/*
		do
			# read original data
			ALL_FASTA="$cell/${chain}.fa"
			READS_1="$cell/$R1"
			READS_2="$cell/$R2"

			# skip the case/cell where a directory does not have required files
			if [ ! -e $ALL_FASTA -o ! -e $READS_1 -o ! -e $READS_2 ]
			then
				echo "Reference file and/or reads were not found ... moving to next cell."
				continue
			fi

			# create subdirectory for each cell analysed
			mkdir $OUTPUT/$(basename $cell)
			cd $OUTPUT/$(basename $cell)

			# construct path for final output file
			CORR_SEQ=$OUTPUT/$(basename $cell)/new_${chain}.fa
			rm -vf accepted_seq_names.txt

			# first tab delimited entry from migmap is the sequence name
			# create a file with names of identified sequences
			migmap -S $ORGANISM --by-read -R ${chain//C} --data-dir=$CONDA_PREFIX/share/igblast $ALL_FASTA - | cut -f1 | egrep "^>.*" >> accepted_seq_names.txt

			## first tab delimited entry from migmap is the sequence name
			## create a file with names of identified sequences
			#cut -f1 | while read x ; do
			#		if [[ "$x" == ">"* ]] ; then
			#			echo "$x" >> accepted_seq_names.txt;
			#		fi;
			#	done

			rm -vrf $CORR_SEQ

			# go through identified sequences and use as reference for alignment
			while read seq_name; do
				# create a fasta reference file with a single sequence, index it as required
				python $SCRIPTS_DIR/extract_fasta.py "$seq_name" $ALL_FASTA # creates reference.fasta
				samtools faidx reference.fasta
				bwa index reference.fasta

				# samtools v1.3.1
				bwa mem reference.fasta $READS_1 $READS_2 | samtools view -b | samtools sort -o alignment.bam

				samtools index alignment.bam
				echo "samtools index finished"

				samtools mpileup -uf reference.fasta alignment.bam |

	# 			if [[ $(hostname) == 'orange' ]] ; then
					bcftools call -c | python $SCRIPTS_DIR/mpileup2cons.py reference.fasta
	# 			else
	# 				# cluster 21
	# 				bcftools view -cg - | python $SCRIPTS_DIR/mpileup2cons.py reference.fasta
	# 			fi

				# http://samtools.sourceforge.net/mpileup.shtml
				# alternative but produces truncated consensus and ambiguous bases
				# use vcfutils, skip first line which is the sequence ID, convert to a single line, stop after the + character (now have the consensus sequence)
				# samtools mpileup -uf reference.fasta alignment.bam | bcftools view -cg - |
					# vcfutils.pl vcf2fq | tail -n +2 | tr -d '\n' | cut -f1 -d +

				echo "writing sequence to file ..."
				cat new_reference.fasta >> $CORR_SEQ
				echo -e "Output located at:\n"$CORR_SEQ

				# Even if we don't remove, they will be overwritten when the next sequence is processed.
				rm -vf new_reference.fasta
				rm -vf reference.fasta*
				rm -vf alignment.bam*

				echo "Done, moving to next sequence"

			done <accepted_seq_names.txt
			rm -vf accepted_seq_names.txt
			echo "Done, moving to next cell"
		done
	done
fi


echo "${RECEPTOR_ABBREV} identification complete! Check your results in the summary directory."
echo `date`
